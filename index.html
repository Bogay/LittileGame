<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>èƒŒåŒ…æ•¸å­¸å¤§å¸«ï¼šé¢ç©æŒ‘æˆ°ç‰ˆ</title>
    <style>
        :root {
            --header-height: 60px;
        }
        body {
            font-family: 'Segoe UI', 'Microsoft JhengHei', sans-serif;
            background-color: #fff8e1;
            margin: 0;
            padding: 0;
            overflow: hidden;
            touch-action: none;
            user-select: none;
            width: 100vw;
            /* é—œéµä¿®æ­£ï¼šä½¿ç”¨ dvh (Dynamic Viewport Height) è§£æ±º iOS Safari åº•éƒ¨è¢«åˆ‡æ‰çš„å•é¡Œ */
            height: 100dvh; 
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        
        /* é ‚éƒ¨å„€è¡¨æ¿ */
        .dashboard {
            flex: 0 0 var(--header-height);
            width: 98%;
            display: flex;
            justify-content: space-between;
            align-items: center;
            background: white;
            padding: 0 15px;
            box-sizing: border-box;
            border-radius: 0 0 15px 15px;
            box-shadow: 0 4px 8px rgba(0,0,0,0.1);
            border-bottom: 3px solid #ffb74d;
            z-index: 10;
        }
        
        .stat-group {
            font-size: clamp(14px, 2vw, 18px);
            font-weight: bold;
            color: #5d4037;
            display: flex;
            gap: 15px;
            align-items: center;
        }

        /* æ•¸å­¸é¡Œç›®æç¤º */
        .unit-badge {
            background: #e1f5fe;
            color: #0277bd;
            padding: 4px 8px;
            border-radius: 5px;
            border: 1px solid #0277bd;
        }

        button {
            padding: 6px 12px;
            font-size: clamp(12px, 1.5vw, 16px);
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-weight: bold;
            color: white;
            box-shadow: 0 2px 0 rgba(0,0,0,0.2);
        }
        button:active { transform: translateY(2px); box-shadow: none; }
        #btn-new { background-color: #66bb6a; }
        #btn-hint { background-color: #ffa726; }

        #math-feedback {
            flex: 0 0 24px; /* å›ºå®šé«˜åº¦ */
            font-size: clamp(14px, 1.8vw, 18px);
            color: #5d4037;
            font-weight: bold;
            display: flex;
            align-items: center;
            justify-content: center;
            width: 100%;
            margin-top: 2px;
            white-space: nowrap;
        }

        /* éŠæˆ²å®¹å™¨ - è‡ªå‹•å¡«æ»¿å‰©é¤˜é«˜åº¦ */
        .game-container {
            flex: 1;
            width: 100%;
            display: flex;
            justify-content: center;
            align-items: center; /* å‚ç›´ç½®ä¸­ */
            padding: 5px;
            box-sizing: border-box;
            overflow: hidden;
        }

        canvas {
            box-shadow: 0 5px 20px rgba(0,0,0,0.15);
            border-radius: 12px;
            background: #eceff1;
            touch-action: none;
            /* ç¢ºä¿ canvas ä¸æœƒå› ç‚ºå¤ªå¤§è€Œè¢«æ“ å£“è®Šå½¢ */
            max-width: 100%; 
            max-height: 100%;
        }

        /* --- æ•¸å­¸æ¸¬é©—å½ˆçª— (Modal) --- */
        .modal-overlay {
            position: fixed;
            top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.5);
            display: none; /* é è¨­éš±è— */
            justify-content: center;
            align-items: center;
            z-index: 100;
            backdrop-filter: blur(3px);
        }
        .modal-box {
            background: white;
            padding: 20px;
            border-radius: 15px;
            box-shadow: 0 10px 25px rgba(0,0,0,0.2);
            text-align: center;
            width: 85%;
            max-width: 400px;
            border: 4px solid #ffb74d;
            animation: popIn 0.3s ease;
        }
        @keyframes popIn { from {transform: scale(0.8); opacity:0;} to {transform: scale(1); opacity:1;} }
        
        .modal-title { font-size: 22px; color: #d81b60; margin-bottom: 10px; font-weight: bold; }
        .modal-question { font-size: 18px; color: #333; margin-bottom: 15px; line-height: 1.5; }
        .modal-input { 
            font-size: 24px; padding: 8px; width: 100px; text-align: center; 
            border: 2px solid #ccc; border-radius: 8px; margin-bottom: 15px;
        }
        .modal-btn {
            padding: 10px 20px; font-size: 18px; border-radius: 8px; border: none; cursor: pointer; color: white;
        }
        .btn-submit { background: #1e88e5; }

    </style>
</head>
<body>

    <div class="dashboard">
        <div class="stat-group">
            <div class="unit-badge">ğŸ“ é‚Šé•·: <span id="unit-len">1</span></div>
            <div>é€²åº¦: <span id="coverage" style="color:#d81b60">0%</span></div>
        </div>
        <div style="display:flex; gap:10px;">
            <button id="btn-hint">ğŸ’¡ æç¤º</button>
            <button id="btn-new">ğŸ”„ é‡ä¾†</button>
        </div>
    </div>

    <div id="math-feedback">æ­¡è¿æŒ‘æˆ°ï¼æ¯ç¨®ç©æœ¨éœ€ç­”å°é¢ç©æ‰èƒ½è§£é–</div>

    <div class="game-container">
        <canvas id="gameCanvas"></canvas>
    </div>

    <div class="modal-overlay" id="quiz-modal">
        <div class="modal-box">
            <div class="modal-title">ğŸ§  é¢ç©å¤§æŒ‘æˆ°</div>
            <div class="modal-question" id="quiz-text">
                é€™å€‹ç©æœ¨ä½”äº† X æ ¼<br>æ¯æ ¼é‚Šé•·æ˜¯ N<br>è«‹å•ç¸½é¢ç©æ˜¯å¤šå°‘ï¼Ÿ
            </div>
            <input type="number" class="modal-input" id="quiz-input" placeholder="?">
            <br>
            <button class="modal-btn btn-submit" id="btn-quiz-submit">é€å‡ºç­”æ¡ˆ</button>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const uiCoverage = document.getElementById('coverage');
        const uiFeedback = document.getElementById('math-feedback');
        const uiUnitLen = document.getElementById('unit-len');
        
        // Modal Elements
        const modal = document.getElementById('quiz-modal');
        const quizText = document.getElementById('quiz-text');
        const quizInput = document.getElementById('quiz-input');
        const quizSubmit = document.getElementById('btn-quiz-submit');

        // --- éŠæˆ²å¸¸æ•¸ ---
        const COLS_BACKPACK = 10;
        const ROWS_BACKPACK = 8;
        const COLS_GAP = 1;
        const COLS_SPAWN = 4; 
        const TOTAL_LOGICAL_COLS = COLS_BACKPACK + COLS_GAP + COLS_SPAWN;
        const TOTAL_LOGICAL_ROWS = ROWS_BACKPACK;

        // --- è®Šæ•¸ (RWD) ---
        let GRID_SIZE = 40;
        let OFFSET_X = 20;
        let OFFSET_Y = 20;
        let BACKPACK_W, BACKPACK_H, SPAWN_X;

        // --- æ•¸å­¸é‚è¼¯è®Šæ•¸ ---
        let UNIT_LENGTH = 1; // éš¨æ©Ÿé‚Šé•·
        const POSSIBLE_LENGTHS = [1, 2, 4, 5, 9, 10]; // å¯èƒ½çš„é‚Šé•·é¸é …
        let unlockStatus = {}; // è¨˜éŒ„æ¯ç¨®ç©æœ¨çš„å‰©é¤˜æ¬¡æ•¸ { 'ruler': 0, 'book': 3 ... }
        let pendingItem = null; // ç­‰å¾…å›ç­”å•é¡Œçš„ç©æœ¨
        let pendingSnapCol = 0; // æš«å­˜æ”¾ç½®ä½ç½®
        let pendingSnapRow = 0;

        let items = [];
        let draggedItem = null;
        let dragOffsetGridX = 0;
        let dragOffsetGridY = 0;
        let lastClickTime = 0;
        let originalPos = {x:0, y:0}; // ç”¨æ–¼ç­”éŒ¯å½ˆå›

        // --- ç‰©å“å®šç¾© ---
        const ITEM_TEMPLATES = {
            'ruler': { name: "é•·å°º", color: '#fdd835', draw: drawRuler },
            'book': { name: "èª²æœ¬", color: '#42a5f5', draw: drawBook },
            'notebook': { name: "ç­†è¨˜æœ¬", color: '#66bb6a', draw: drawNotebook },
            'pencil_box': { name: "é‰›ç­†ç›’", color: '#ef5350', draw: drawPencilBox },
            'eraser': { name: "æ©¡çš®æ“¦", color: '#eceff1', draw: drawEraser },
            'headphones': { name: "è€³æ©Ÿ", color: '#ab47bc', draw: drawHeadphones },
            'gameboy': { name: "éŠæˆ²æ©Ÿ", color: '#26c6da', draw: drawGameboy },
            'tetris': { name: "ç©æœ¨", color: '#ff7043', draw: drawTetris }
        };

        const SHAPES = [
            [[1,1,1,1]], // 1x4
            [[1,1,1],[1,0,0]], // L
            [[1,1],[1,1]], // 2x2
            [[1,1,1],[0,1,0]], // T
            [[1,1],[1,0],[1,0]], // Long L
            [[1,1,1]], // 1x3
            [[1,1]], // 1x2
            [[1]] // 1x1
        ];

        class Item {
            constructor(shape, logicalX, logicalY, templateKey) {
                this.shape = shape;
                this.logicalX = logicalX;
                this.logicalY = logicalY;
                this.templateKey = templateKey; // å„²å­˜ key ä»¥ä¾¿æŸ¥è©¢è§£é–ç‹€æ…‹
                this.template = ITEM_TEMPLATES[templateKey];
                this.color = this.template.color;
                this.isInside = false;
                this.updateDimensions();
            }

            updateDimensions() {
                this.rows = this.shape.length;
                this.cols = this.shape[0].length;
                this.area = 0; // æ ¼å­æ•¸
                for(let r=0; r<this.rows; r++) {
                    for(let c=0; c<this.cols; c++) {
                        if(this.shape[r][c] === 1) this.area++;
                    }
                }
            }

            rotate() {
                const newRows = this.cols;
                const newCols = this.rows;
                let newShape = new Array(newRows).fill(0).map(() => new Array(newCols).fill(0));
                for(let r=0; r<this.rows; r++) {
                    for(let c=0; c<this.cols; c++) {
                        newShape[c][this.rows - 1 - r] = this.shape[r][c];
                    }
                }
                this.shape = newShape;
                this.updateDimensions();
            }

            draw(ctx) {
                const px = OFFSET_X + this.logicalX * GRID_SIZE;
                const py = OFFSET_Y + this.logicalY * GRID_SIZE;
                if (this.template.draw) {
                    this.template.draw(ctx, px, py, this);
                }
                
                // å¦‚æœæ˜¯è¢«é–å®šçš„ç‹€æ…‹ï¼Œé¡¯ç¤ºä¸€å€‹å°é–é ­ (é¸ç”¨)
                if (unlockStatus[this.templateKey] <= 0 && !this.isInside && draggedItem !== this) {
                   ctx.fillStyle = "rgba(0,0,0,0.3)";
                   ctx.font = "16px Arial";
                   ctx.fillText("ğŸ”’", px, py + 16);
                }
            }

            hitTest(mx, my) {
                const px = OFFSET_X + this.logicalX * GRID_SIZE;
                const py = OFFSET_Y + this.logicalY * GRID_SIZE;
                if (mx < px || mx > px + this.cols * GRID_SIZE || my < py || my > py + this.rows * GRID_SIZE) return false;
                const col = Math.floor((mx - px) / GRID_SIZE);
                const row = Math.floor((my - py) / GRID_SIZE);
                if (row >= 0 && row < this.rows && col >= 0 && col < this.cols) {
                    return this.shape[row][col] === 1;
                }
                return false;
            }
        }

        // --- ç¹ªåœ– Helper Functions ---
        function drawBaseBlock(ctx, x, y, color, size) {
            ctx.fillStyle = color;
            ctx.fillRect(x, y, size, size);
            ctx.fillStyle = "rgba(255,255,255,0.3)";
            ctx.fillRect(x, y, size, size * 0.15);
            ctx.fillStyle = "rgba(0,0,0,0.1)";
            ctx.fillRect(x, y + size * 0.85, size, size * 0.15);
            ctx.strokeStyle = "rgba(0,0,0,0.15)";
            ctx.strokeRect(x, y, size, size);
        }
        function iterateShape(item, startX, startY, callback) {
            for(let r=0; r<item.rows; r++) {
                for(let c=0; c<item.cols; c++) {
                    if(item.shape[r][c] === 1) callback(startX + c * GRID_SIZE, startY + r * GRID_SIZE, r, c);
                }
            }
        }
        
        // --- å„ç¨®ç‰©å“ç¹ªè£½ ---
        function drawRuler(ctx, px, py, item) {
            iterateShape(item, px, py, (x, y) => {
                drawBaseBlock(ctx, x, y, item.color, GRID_SIZE);
                ctx.strokeStyle = "#5d4037"; ctx.lineWidth = 2;
                ctx.beginPath(); ctx.moveTo(x+GRID_SIZE*0.5, y); ctx.lineTo(x+GRID_SIZE*0.5, y+GRID_SIZE*0.5); ctx.stroke();
            });
        }
        function drawEraser(ctx, px, py, item) {
            iterateShape(item, px, py, (x, y) => {
                ctx.fillStyle = "#f5f5f5"; ctx.fillRect(x, y, GRID_SIZE, GRID_SIZE);
                ctx.fillStyle = "#1e88e5"; ctx.fillRect(x+2, y+GRID_SIZE*0.4, GRID_SIZE-4, GRID_SIZE*0.55);
                ctx.strokeStyle="#ccc"; ctx.strokeRect(x,y,GRID_SIZE,GRID_SIZE);
            });
        }
        function drawGameboy(ctx, px, py, item) {
             iterateShape(item, px, py, (x, y) => {
                drawBaseBlock(ctx, x, y, item.color, GRID_SIZE);
                ctx.fillStyle="#004d40"; ctx.fillRect(x+4, y+4, GRID_SIZE-8, GRID_SIZE*0.4);
                ctx.fillStyle="#d32f2f"; ctx.beginPath(); ctx.arc(x+GRID_SIZE*0.8, y+GRID_SIZE*0.75, 4, 0, Math.PI*2); ctx.fill();
            });
        }
        function drawBook(ctx, px, py, item) {
            iterateShape(item, px, py, (x, y) => { drawBaseBlock(ctx, x, y, item.color, GRID_SIZE); ctx.fillStyle="rgba(255,255,255,0.4)"; ctx.fillRect(x+4,y,4,GRID_SIZE); });
        }
        function drawNotebook(ctx, px, py, item) {
            iterateShape(item, px, py, (x, y, r) => { drawBaseBlock(ctx, x, y, item.color, GRID_SIZE); if(r===0){ ctx.fillStyle="#333"; ctx.beginPath(); ctx.arc(x+GRID_SIZE/2, y+4, 3, 0, Math.PI*2); ctx.fill();} });
        }
        function drawPencilBox(ctx, px, py, item) {
            iterateShape(item, px, py, (x, y) => { drawBaseBlock(ctx, x, y, item.color, GRID_SIZE); ctx.fillStyle="rgba(0,0,0,0.2)"; ctx.fillRect(x, y+GRID_SIZE/2, GRID_SIZE, 4); });
        }
        function drawHeadphones(ctx, px, py, item) {
             iterateShape(item, px, py, (x, y) => { drawBaseBlock(ctx, x, y, item.color, GRID_SIZE); ctx.fillStyle="rgba(0,0,0,0.3)"; ctx.font=`${GRID_SIZE/2}px Arial`; ctx.textAlign="center"; ctx.fillText("ğŸ§", x+GRID_SIZE/2, y+GRID_SIZE/2+6); });
        }
        function drawTetris(ctx, px, py, item) {
             iterateShape(item, px, py, (x, y) => { drawBaseBlock(ctx, x, y, item.color, GRID_SIZE); ctx.strokeStyle="white"; ctx.strokeRect(x+4, y+4, GRID_SIZE-8, GRID_SIZE-8); });
        }

        // --- RWD è‡ªé©æ‡‰ (è§£æ±º iPad åˆ‡åˆ°å•é¡Œ) ---
        function resizeGame() {
            const headerH = document.querySelector('.dashboard').offsetHeight;
            const feedbackH = document.getElementById('math-feedback').offsetHeight;
            const availableH = window.innerHeight - headerH - feedbackH - 20; // 20px buffer
            const availableW = window.innerWidth - 10;

            // è¨ˆç®—æœ€ä½³ GRID_SIZE
            const sizeByW = availableW / TOTAL_LOGICAL_COLS;
            const sizeByH = availableH / TOTAL_LOGICAL_ROWS;

            GRID_SIZE = Math.floor(Math.min(sizeByW, sizeByH));
            
            // è®“ç•«é¢ç½®ä¸­
            const contentW = TOTAL_LOGICAL_COLS * GRID_SIZE;
            const contentH = TOTAL_LOGICAL_ROWS * GRID_SIZE;
            
            OFFSET_X = Math.floor((availableW - contentW) / 2) + 5;
            OFFSET_Y = Math.floor((availableH - contentH) / 2); // ä¸åŠ  headerHï¼Œå› ç‚º canvas åœ¨ flex å®¹å™¨å…§

            BACKPACK_W = COLS_BACKPACK * GRID_SIZE;
            BACKPACK_H = ROWS_BACKPACK * GRID_SIZE;
            SPAWN_X = OFFSET_X + (COLS_BACKPACK + COLS_GAP) * GRID_SIZE;

            canvas.width = availableW;
            canvas.height = availableH;
            draw();
        }

        // --- é‚è¼¯ï¼šç”Ÿæˆèˆ‡é‡ç½® ---
        function createSolvablePuzzle() {
            // 1. éš¨æ©Ÿé‚Šé•·
            UNIT_LENGTH = POSSIBLE_LENGTHS[Math.floor(Math.random() * POSSIBLE_LENGTHS.length)];
            uiUnitLen.innerText = UNIT_LENGTH;
            
            // 2. é‡ç½®è§£é–ç‹€æ…‹
            unlockStatus = {};
            Object.keys(ITEM_TEMPLATES).forEach(key => unlockStatus[key] = 0);

            items = [];
            let grid = new Array(ROWS_BACKPACK).fill(0).map(() => new Array(COLS_BACKPACK).fill(0));
            
            // å¡«æ»¿ç¶²æ ¼ç”Ÿæˆæ‹¼åœ–
            for(let r=0; r<ROWS_BACKPACK; r++) {
                for(let c=0; c<COLS_BACKPACK; c++) {
                    if(grid[r][c] === 0) placeRandomShape(grid, r, c);
                }
            }
            
            // æ•£å¸ƒåˆ°å³å´
            let spawnCol = COLS_BACKPACK + COLS_GAP;
            items.forEach((item) => {
                item.isInside = false;
                item.logicalX = spawnCol + Math.random() * (COLS_SPAWN - item.cols);
                item.logicalY = Math.random() * (ROWS_BACKPACK - item.rows);
                
                // éš¨æ©Ÿæ—‹è½‰
                let rots = Math.floor(Math.random() * 4);
                for(let i=0; i<rots; i++) item.rotate();
                
                // é‚Šç•Œæª¢æŸ¥
                if (item.logicalX + item.cols > TOTAL_LOGICAL_COLS) item.logicalX = TOTAL_LOGICAL_COLS - item.cols;
                if (item.logicalY + item.rows > TOTAL_LOGICAL_ROWS) item.logicalY = TOTAL_LOGICAL_ROWS - item.rows;
            });
        }

        function placeRandomShape(grid, r, c) {
            let shapesToTry = [...SHAPES].sort(() => Math.random() - 0.5);
            for (let shape of shapesToTry) {
                if (canFit(grid, r, c, shape)) {
                    let templateKey = assignTheme(shape);
                    items.push(new Item(shape, 0, 0, templateKey));
                    markGrid(grid, r, c, shape, 1);
                    return;
                }
            }
        }
        function canFit(grid, r, c, shape) {
            let rows = shape.length; let cols = shape[0].length;
            if (r + rows > ROWS_BACKPACK || c + cols > COLS_BACKPACK) return false;
            for(let i=0; i<rows; i++) {
                for(let j=0; j<cols; j++) { if (shape[i][j] === 1 && grid[r+i][c+j] === 1) return false; }
            }
            return true;
        }
        function markGrid(grid, r, c, shape, val) {
            let rows = shape.length; let cols = shape[0].length;
            for(let i=0; i<rows; i++) {
                for(let j=0; j<cols; j++) { if (shape[i][j] === 1) grid[r+i][c+j] = val; }
            }
        }
        function assignTheme(shape) {
            let area = 0; shape.flat().forEach(v => area += v);
            if (area === 1) return 'eraser';
            if (shape.length === 1 || shape[0].length === 1) return (area >= 3) ? 'ruler' : 'pencil_box';
            let isRect = true; for(let row of shape) if(row.includes(0)) isRect = false;
            if (isRect) return (area >= 4) ? (Math.random()>0.5?'book':'notebook') : 'tetris';
            let rand = Math.random(); return (rand < 0.3) ? 'headphones' : (rand < 0.6 ? 'gameboy' : 'tetris');
        }

        // --- äº’å‹•è™•ç† ---
        function checkCollision(currentItem, targetCol, targetRow) {
            for(let r=0; r<currentItem.rows; r++) {
                for(let c=0; c<currentItem.cols; c++) {
                    if (currentItem.shape[r][c] === 1) {
                        let gc = targetCol + c; let gr = targetRow + r;
                        if (gc < 0 || gc >= COLS_BACKPACK || gr < 0 || gr >= ROWS_BACKPACK) return true;
                    }
                }
            }
            for (let other of items) {
                if (other === currentItem || !other.isInside) continue;
                let otherCol = Math.round(other.logicalX); let otherRow = Math.round(other.logicalY);
                for(let r=0; r<currentItem.rows; r++) {
                    for(let c=0; c<currentItem.cols; c++) {
                        if(currentItem.shape[r][c] === 1) {
                            let relCol = (targetCol + c) - otherCol; let relRow = (targetRow + r) - otherRow;
                            if (relCol >= 0 && relCol < other.cols && relRow >= 0 && relRow < other.rows) {
                                if (other.shape[relRow][relCol] === 1) return true;
                            }
                        }
                    }
                }
            }
            return false;
        }

        // --- æ•¸å­¸æ¸¬é©—é‚è¼¯ ---
        function handleDrop(item, col, row) {
            // 1. å¦‚æœä½ç½®ä¸åˆæ³•ï¼Œç›´æ¥å¤±æ•—
            if (checkCollision(item, col, row)) {
                returnToSpawn(item, "â›” ä½ç½®é‡ç–Šæˆ–è¶…å‡ºç¯„åœ");
                return;
            }

            // 2. æª¢æŸ¥æ˜¯å¦å·²è§£é–
            let remaining = unlockStatus[item.templateKey];
            if (remaining > 0) {
                // å·²è§£é– -> ç›´æ¥æ”¾ç½®
                placeSuccess(item, col, row);
                unlockStatus[item.templateKey]--;
                uiFeedback.innerText = `âœ… æ”¾ç½®æˆåŠŸ (å‰©é¤˜å…è²»æ¬¡æ•¸: ${unlockStatus[item.templateKey]})`;
            } else {
                // æœªè§£é– -> å½ˆå‡ºé¡Œç›®
                showMathQuiz(item, col, row);
            }
        }

        function showMathQuiz(item, col, row) {
            pendingItem = item;
            pendingSnapCol = col;
            pendingSnapRow = row;
            
            // è¨ˆç®—çœŸå¯¦é¢ç©
            // ç¸½é¢ç© = æ ¼å­æ•¸ * (é‚Šé•· * é‚Šé•·)
            // ä¾‹å¦‚: 4æ ¼ç©æœ¨, é‚Šé•·10 => 4 * 100 = 400
            let areaUnit = UNIT_LENGTH * UNIT_LENGTH;
            let totalArea = item.area * areaUnit;

            quizText.innerHTML = `
                é€™å€‹ç©æœ¨ä½”äº† <b style="color:#d81b60; font-size:1.2em;">${item.area}</b> æ ¼<br>
                æ¯æ ¼é‚Šé•·æ˜¯ <b style="color:#0277bd; font-size:1.2em;">${UNIT_LENGTH}</b><br>
                è«‹å•ç¸½é¢ç©æ˜¯å¤šå°‘ï¼Ÿ
            `;
            quizInput.value = "";
            modal.style.display = "flex";
            quizInput.focus();
        }

        quizSubmit.addEventListener('click', checkAnswer);

        function checkAnswer() {
            if (!pendingItem) return;
            
            let inputVal = parseInt(quizInput.value);
            let correctVal = pendingItem.area * (UNIT_LENGTH * UNIT_LENGTH);

            if (inputVal === correctVal) {
                // ç­”å°
                unlockStatus[pendingItem.templateKey] = 2; // é€™æ¬¡ç”¨äº†ï¼Œé‚„å‰©2æ¬¡ (å…±3æ¬¡)
                placeSuccess(pendingItem, pendingSnapCol, pendingSnapRow);
                uiFeedback.innerText = `ğŸ‰ ç­”å°äº†ï¼è§£é–é€£çºŒæ”¾ç½®æ¬Šé™ï¼`;
                uiFeedback.style.color = "green";
                modal.style.display = "none";
            } else {
                // ç­”éŒ¯
                returnToSpawn(pendingItem, "âŒ ç­”æ¡ˆéŒ¯èª¤ï¼ç©æœ¨å½ˆå›");
                modal.style.display = "none";
            }
            pendingItem = null;
        }

        function placeSuccess(item, col, row) {
            item.logicalX = col;
            item.logicalY = row;
            item.isInside = true;
            if(navigator.vibrate) navigator.vibrate(30);
            updateStats();
            draw();
        }

        function returnToSpawn(item, msg) {
            // ç°¡å–®çš„å½ˆå›é‚è¼¯ï¼šæ”¾å›åŸä¾†è¢«æ‹–æ›³å‰çš„ä½ç½®ï¼Œæˆ–éš¨æ©Ÿä¸€å€‹ spawn ä½ç½®
            // é€™è£¡ç°¡å–®æ”¾å›åŸå§‹ä½ç½®
            item.logicalX = originalPos.x;
            item.logicalY = originalPos.y;
            item.isInside = false;
            uiFeedback.innerText = msg;
            uiFeedback.style.color = "#d32f2f";
            draw();
        }

        function updateStats() {
            let usedArea = 0;
            items.forEach(item => { if (item.isInside) usedArea += item.area; });
            let percentage = Math.round((usedArea / (COLS_BACKPACK * ROWS_BACKPACK)) * 100);
            uiCoverage.innerText = percentage + "%";
        }

        // --- æŒ‡æ¨™äº‹ä»¶ ---
        function getPointerPos(e) {
            const rect = canvas.getBoundingClientRect();
            const cx = e.touches ? e.touches[0].clientX : e.clientX;
            const cy = e.touches ? e.touches[0].clientY : e.clientY;
            return { x: cx - rect.left, y: cy - rect.top };
        }

        function handleStart(e) {
            if (e.type === 'touchstart') e.preventDefault();
            const pos = getPointerPos(e);
            const now = new Date().getTime();

            for (let i = items.length - 1; i >= 0; i--) {
                let item = items[i];
                if (item.hitTest(pos.x, pos.y)) {
                    if (now - lastClickTime < 300) {
                        item.rotate();
                        draw();
                        lastClickTime = 0; return;
                    }
                    lastClickTime = now;
                    
                    draggedItem = item;
                    // ç´€éŒ„åŸå§‹ä½ç½®ï¼Œä»¥ä¾¿ç­”éŒ¯å½ˆå›
                    originalPos = { x: item.logicalX, y: item.logicalY };

                    const itemPx = OFFSET_X + item.logicalX * GRID_SIZE;
                    const itemPy = OFFSET_Y + item.logicalY * GRID_SIZE;
                    dragOffsetGridX = (pos.x - itemPx) / GRID_SIZE;
                    dragOffsetGridY = (pos.y - itemPy) / GRID_SIZE;

                    items.splice(i, 1); items.push(item);
                    draw(); return;
                }
            }
        }

        function handleMove(e) {
            if (draggedItem) {
                if (e.type === 'touchmove') e.preventDefault();
                const pos = getPointerPos(e);
                draggedItem.logicalX = (pos.x / GRID_SIZE) - dragOffsetGridX - (OFFSET_X / GRID_SIZE);
                draggedItem.logicalY = (pos.y / GRID_SIZE) - dragOffsetGridY - (OFFSET_Y / GRID_SIZE);
                draw();
            }
        }

        function handleEnd(e) {
            if (draggedItem) {
                const snapCol = Math.round(draggedItem.logicalX);
                const snapRow = Math.round(draggedItem.logicalY);
                
                // åªæœ‰ç•¶å˜—è©¦æ”¾å…¥èƒŒåŒ…å€æ™‚æ‰è§¸ç™¼é‚è¼¯
                // å¦‚æœé‚„æ˜¯åœ¨ç‰©å“å€ (col >= 10)ï¼Œå°±åªæ˜¯æ™®é€šç§»å‹•
                if (snapCol < COLS_BACKPACK) {
                    handleDrop(draggedItem, snapCol, snapRow);
                } else {
                    // åœ¨ç‰©å“å€ç§»å‹•ï¼Œç›´æ¥æ”¾ç½®
                    draggedItem.logicalX = snapCol;
                    draggedItem.logicalY = snapRow;
                    draw();
                }
                draggedItem = null;
            }
        }

        canvas.addEventListener('mousedown', handleStart);
        canvas.addEventListener('mousemove', handleMove);
        canvas.addEventListener('mouseup', handleEnd);
        canvas.addEventListener('touchstart', handleStart, {passive: false});
        canvas.addEventListener('touchmove', handleMove, {passive: false});
        canvas.addEventListener('touchend', handleEnd);

        document.getElementById('btn-new').addEventListener('click', () => { createSolvablePuzzle(); updateStats(); draw(); });
        document.getElementById('btn-hint').addEventListener('click', () => { uiFeedback.innerText = "ğŸ’¡ é›™æ“Šç©æœ¨å¯æ—‹è½‰ï¼Œç­”å°é¢ç©å¯è§£é–ï¼"; });
        window.addEventListener('resize', resizeGame);

        createSolvablePuzzle();
        setTimeout(resizeGame, 50);

    </script>
</body>
</html>
