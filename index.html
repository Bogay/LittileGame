<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>èƒŒåŒ…æ•¸å­¸å¤§å¸«ï¼šå¹³æ¿å„ªåŒ–ç‰ˆ</title>
    <style>
        body {
            font-family: 'Segoe UI', 'Microsoft JhengHei', sans-serif;
            background-color: #fff8e1;
            display: flex;
            flex-direction: column;
            align-items: center;
            margin: 0;
            padding: 10px;
            overscroll-behavior: none; /* ç¦æ­¢ iOS å½ˆæ€§æ²å‹•æ•ˆæœ */
            touch-action: none; /* ç¦æ­¢é è¨­è§¸æ§æ‰‹å‹¢ */
            user-select: none;
            height: 100vh;
            box-sizing: border-box;
        }
        
        /* é ‚éƒ¨è³‡è¨Šåˆ— (å„€è¡¨æ¿é¢¨æ ¼) */
        .dashboard {
            display: flex;
            width: 100%;
            max-width: 700px;
            justify-content: space-between;
            align-items: center;
            background: white;
            padding: 8px 15px;
            border-radius: 12px;
            box-shadow: 0 4px 10px rgba(0,0,0,0.1);
            margin-bottom: 10px;
            border: 2px solid #ffb74d;
        }
        
        .stat-group {
            display: flex;
            gap: 15px;
            font-size: 16px;
            font-weight: bold;
            color: #5d4037;
            align-items: center;
        }

        .btn-group {
            display: flex;
            gap: 8px;
        }

        button {
            padding: 8px 16px;
            font-size: 15px;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-weight: bold;
            color: white;
            box-shadow: 0 2px 0 rgba(0,0,0,0.2);
        }
        button:active { transform: translateY(2px); box-shadow: none; }
        #btn-new { background-color: #66bb6a; }
        #btn-hint { background-color: #ffa726; }

        /* æç¤ºèˆ‡å›é¥‹æ–‡å­— */
        #math-feedback {
            height: 24px;
            font-size: 16px;
            color: #5d4037;
            font-weight: bold;
            text-align: center;
            margin-bottom: 5px;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .game-container {
            position: relative;
            border-radius: 12px;
            overflow: hidden;
            box-shadow: 0 8px 20px rgba(0,0,0,0.2);
            background: #eceff1;
            border: 3px solid #8d6e63;
        }

        canvas {
            display: block; /* ç§»é™¤ canvas åº•éƒ¨ç™½é‚Š */
            cursor: grab;
        }
        canvas:active { cursor: grabbing; }

    </style>
</head>
<body>

    <div class="dashboard">
        <div class="stat-group">
            <div>ğŸ¯ ç›®æ¨™: 80æ ¼</div>
            <div>ğŸ“Š é€²åº¦: <span id="coverage" style="color:#d81b60">0%</span></div>
        </div>
        <div class="btn-group">
            <button id="btn-hint">ğŸ’¡ æç¤º</button>
            <button id="btn-new">ğŸ”„ é‡ä¾†</button>
        </div>
    </div>

    <div id="math-feedback">æ‹–æ›³ç‰©å“å…¥èƒŒåŒ… | ğŸ‘† é›™æ“Šç‰©å“æ—‹è½‰</div>

    <div class="game-container">
        <canvas id="gameCanvas" width="550" height="350"></canvas>
    </div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const uiCoverage = document.getElementById('coverage');
        const uiFeedback = document.getElementById('math-feedback');

        // --- èª¿æ•´å¾Œçš„åƒæ•¸ (æ›´é©åˆ iPad) ---
        const GRID_SIZE = 38; // ç¨å¾®ç¸®å°ï¼Œè®“ç•«é¢å®¹ç´æ›´å¤š
        const GRID_COLS = 10; 
        const GRID_ROWS = 8;  
        
        const OFFSET_X = 15; // å·¦é‚Šè·
        const OFFSET_Y = 15; // ä¸Šé‚Šè·
        
        // èƒŒåŒ…å¯¦éš›é¡¯ç¤ºå€åŸŸ
        const BACKPACK_W = GRID_COLS * GRID_SIZE;
        const BACKPACK_H = GRID_ROWS * GRID_SIZE;
        
        // ç‰©å“ç”Ÿæˆå€ (å³å´)
        const SPAWN_AREA_X = BACKPACK_W + OFFSET_X + 20;
        const SPAWN_AREA_W = 130; // ç¸®çª„ç‰©å“å€

        // è‡ªå‹•èª¿æ•´ç•«å¸ƒå¤§å°ä»¥é©æ‡‰å…§å®¹
        canvas.width = SPAWN_AREA_X + SPAWN_AREA_W + 10;
        canvas.height = BACKPACK_H + OFFSET_Y * 2;

        let items = [];
        let draggedItem = null;
        let dragOffsetX = 0;
        let dragOffsetY = 0;
        let lastClickTime = 0;

        // --- ç‰©å“å¤–è§€å®šç¾© ---
        const ITEM_TEMPLATES = {
            'ruler': { name: "é•·å°º", color: '#fdd835', draw: drawRuler },
            'book': { name: "èª²æœ¬", color: '#42a5f5', draw: drawBook },
            'notebook': { name: "ç­†è¨˜æœ¬", color: '#66bb6a', draw: drawNotebook },
            'pencil_box': { name: "é‰›ç­†ç›’", color: '#ef5350', draw: drawPencilBox },
            'eraser': { name: "æ©¡çš®æ“¦", color: '#eceff1', draw: drawEraser }, // æ”¹ç‚ºç™½è‰²åº•
            'headphones': { name: "è€³æ©Ÿ", color: '#ab47bc', draw: drawHeadphones },
            'gameboy': { name: "éŠæˆ²æ©Ÿ", color: '#26c6da', draw: drawGameboy },
            'tetris': { name: "ç©æœ¨", color: '#ff7043', draw: drawTetris }
        };

        const SHAPES = [
            [[1,1,1,1]], // 1x4
            [[1,1,1],[1,0,0]], // L
            [[1,1],[1,1]], // 2x2
            [[1,1,1],[0,1,0]], // T
            [[1,1],[1,0],[1,0]], // Long L
            [[1,1,1]], // 1x3
            [[1,1]], // 1x2
            [[1]] // 1x1
        ];

        class Item {
            constructor(shape, x, y, templateKey) {
                this.shape = shape; 
                this.x = x;
                this.y = y;
                this.template = ITEM_TEMPLATES[templateKey];
                this.color = this.template.color;
                this.isInside = false;
                this.rotationIndex = 0;
                this.updateDimensions();
            }

            updateDimensions() {
                this.rows = this.shape.length;
                this.cols = this.shape[0].length;
                this.area = 0;
                for(let r=0; r<this.rows; r++) {
                    for(let c=0; c<this.cols; c++) {
                        if(this.shape[r][c] === 1) this.area++;
                    }
                }
            }

            rotate() {
                const newRows = this.cols;
                const newCols = this.rows;
                let newShape = new Array(newRows).fill(0).map(() => new Array(newCols).fill(0));
                for(let r=0; r<this.rows; r++) {
                    for(let c=0; c<this.cols; c++) {
                        newShape[c][this.rows - 1 - r] = this.shape[r][c];
                    }
                }
                this.shape = newShape;
                this.updateDimensions();
            }

            draw(ctx) {
                if (this.template.draw) {
                    this.template.draw(ctx, this);
                }
            }

            hitTest(mx, my) {
                if (mx < this.x || mx > this.x + this.cols * GRID_SIZE ||
                    my < this.y || my > this.y + this.rows * GRID_SIZE) return false;
                
                const col = Math.floor((mx - this.x) / GRID_SIZE);
                const row = Math.floor((my - this.y) / GRID_SIZE);
                if (row >= 0 && row < this.rows && col >= 0 && col < this.cols) {
                    return this.shape[row][col] === 1;
                }
                return false;
            }
        }

        // --- ç¹ªåœ–å‡½æ•¸ (å„ªåŒ–ç‰ˆ) ---

        function drawBaseBlock(ctx, x, y, color) {
            ctx.fillStyle = color;
            ctx.fillRect(x, y, GRID_SIZE, GRID_SIZE);
            // å…§é™°å½±/é«˜å…‰å¢åŠ ç«‹é«”æ„Ÿ
            ctx.fillStyle = "rgba(255,255,255,0.2)";
            ctx.fillRect(x, y, GRID_SIZE, 4); // Top highlight
            ctx.fillStyle = "rgba(0,0,0,0.1)";
            ctx.fillRect(x, y + GRID_SIZE - 4, GRID_SIZE, 4); // Bottom shadow
            ctx.strokeStyle = "rgba(0,0,0,0.15)";
            ctx.strokeRect(x, y, GRID_SIZE, GRID_SIZE);
        }

        function iterateShape(item, callback) {
            for(let r=0; r<item.rows; r++) {
                for(let c=0; c<item.cols; c++) {
                    if(item.shape[r][c] === 1) {
                        callback(item.x + c * GRID_SIZE, item.y + r * GRID_SIZE, r, c);
                    }
                }
            }
        }

        function drawRuler(ctx, item) {
            iterateShape(item, (x, y, r, c) => {
                drawBaseBlock(ctx, x, y, item.color);
                // åˆ»åº¦
                ctx.strokeStyle = "#5d4037";
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.moveTo(x + 10, y); ctx.lineTo(x + 10, y + 10);
                ctx.moveTo(x + 20, y); ctx.lineTo(x + 20, y + 15); // é•·åˆ»åº¦
                ctx.moveTo(x + 30, y); ctx.lineTo(x + 30, y + 10);
                ctx.stroke();
            });
        }

        function drawEraser(ctx, item) {
            // æ”¹è‰¯ï¼šè—è‰²ç´™å¥— + ç™½è‰²æ©¡çš®
            iterateShape(item, (x, y, r, c) => {
                // 1. ç•«ç™½è‰²åº• (æ©¡çš®éƒ¨åˆ†)
                ctx.fillStyle = "#f5f5f5"; 
                ctx.fillRect(x, y, GRID_SIZE, GRID_SIZE);
                ctx.strokeStyle = "#ccc";
                ctx.strokeRect(x, y, GRID_SIZE, GRID_SIZE);

                // 2. ç•«è—è‰²ç´™å¥— (è¦†è“‹ä¸‹åŠéƒ¨)
                ctx.fillStyle = "#1e88e5"; // ç¶“å…¸è—
                // è®“è—è‰²ç´™å¥—ç¨å¾®å°ä¸€é»é»ï¼Œçœ‹èµ·ä¾†åƒåŒ…åœ¨å¤–é¢
                const sleeveH = GRID_SIZE * 0.6;
                const sleeveY = y + (GRID_SIZE - sleeveH);
                ctx.fillRect(x + 2, sleeveY - 2, GRID_SIZE - 4, sleeveH);
                
                // 3. ç°¡å–®çš„è£é£¾ç·š
                ctx.fillStyle = "rgba(0,0,0,0.2)";
                ctx.fillRect(x + 5, sleeveY + 5, GRID_SIZE - 10, 2);
            });
        }

        function drawGameboy(ctx, item) {
            // æ”¹è‰¯ï¼šç¢ºä¿å…§å®¹ä¸è¶…å‡ºæ ¼å­
            iterateShape(item, (x, y, r, c) => {
                // æ©Ÿèº«
                drawBaseBlock(ctx, x, y, item.color);
                
                // ç•«ä¸€å€‹å…§ç¸®çš„è¢å¹•å€ï¼Œé¿å…è²¼é‚Š
                const margin = 6;
                ctx.fillStyle = "#004d40"; // æ·±ç¶ è¢å¹•
                ctx.fillRect(x + margin, y + margin, GRID_SIZE - margin*2, GRID_SIZE/2 - margin);
                
                // ç•«æŒ‰éˆ• (ç°¡å–®ç´…é»)
                ctx.fillStyle = "#d32f2f";
                ctx.beginPath();
                ctx.arc(x + GRID_SIZE - 12, y + GRID_SIZE - 12, 4, 0, Math.PI*2);
                ctx.fill();
                
                // åå­—éµæ¨¡æ“¬
                ctx.fillStyle = "#333";
                ctx.fillRect(x + 8, y + GRID_SIZE - 14, 8, 2);
                ctx.fillRect(x + 11, y + GRID_SIZE - 17, 2, 8);
            });
        }

        function drawBook(ctx, item) {
            iterateShape(item, (x, y, r, c) => {
                drawBaseBlock(ctx, x, y, item.color);
                // æ›¸è„Š (åªç•«åœ¨æœ€å·¦é‚Šçš„æ ¼å­ï¼Œæˆ–æ¯å€‹æ ¼å­éƒ½æœ‰è£é£¾)
                ctx.fillStyle = "rgba(255,255,255,0.3)";
                ctx.fillRect(x + 4, y, 6, GRID_SIZE);
                
                // æ›¸å (åªç•«ä¸€æ¬¡ï¼Œåœ¨ä¸­å¿ƒ)
                if (r === Math.floor(item.rows/2) && c === Math.floor(item.cols/2)) {
                    ctx.fillStyle = "white";
                    ctx.font = "bold 12px Arial";
                    ctx.textAlign = "center";
                    ctx.textBaseline = "middle";
                    ctx.fillText("MATH", x + GRID_SIZE/2, y + GRID_SIZE/2);
                }
            });
        }

        function drawNotebook(ctx, item) {
            iterateShape(item, (x, y, r, c) => {
                drawBaseBlock(ctx, x, y, item.color);
                // èºæ—‹å­”
                ctx.fillStyle = "#333";
                if (r === 0) { // åªåœ¨æœ€ä¸Šé¢é‚£ä¸€æ’ç•«
                    ctx.beginPath();
                    ctx.arc(x + 10, y + 4, 2, 0, Math.PI*2);
                    ctx.arc(x + 20, y + 4, 2, 0, Math.PI*2);
                    ctx.arc(x + 30, y + 4, 2, 0, Math.PI*2);
                    ctx.fill();
                }
                // æ©«ç·š
                ctx.fillStyle = "rgba(255,255,255,0.4)";
                ctx.fillRect(x+5, y+15, GRID_SIZE-10, 2);
                ctx.fillRect(x+5, y+25, GRID_SIZE-10, 2);
            });
        }

        function drawPencilBox(ctx, item) {
            iterateShape(item, (x, y, r, c) => {
                drawBaseBlock(ctx, x, y, item.color);
                // æ‹‰éŠç·š
                ctx.fillStyle = "rgba(0,0,0,0.3)";
                ctx.fillRect(x, y + GRID_SIZE/2 - 1, GRID_SIZE, 2);
            });
        }

        function drawHeadphones(ctx, item) {
            iterateShape(item, (x, y, r, c) => {
                drawBaseBlock(ctx, x, y, item.color);
                // ç°¡åŒ–åœ–ç¤º
                ctx.font = "16px Arial";
                ctx.textAlign = "center";
                ctx.textBaseline = "middle";
                ctx.fillText("ğŸ§", x + GRID_SIZE/2, y + GRID_SIZE/2);
            });
        }

        function drawTetris(ctx, item) {
            iterateShape(item, (x, y, r, c) => {
                drawBaseBlock(ctx, x, y, item.color);
                // å…§æ¡†è£é£¾
                ctx.strokeStyle = "rgba(255,255,255,0.5)";
                ctx.strokeRect(x+4, y+4, GRID_SIZE-8, GRID_SIZE-8);
            });
        }

        // --- æ ¸å¿ƒé‚è¼¯ ---

        function createSolvablePuzzle() {
            items = [];
            let grid = new Array(GRID_ROWS).fill(0).map(() => new Array(GRID_COLS).fill(0));
            
            // å¡«æ»¿ç¶²æ ¼
            for(let r=0; r<GRID_ROWS; r++) {
                for(let c=0; c<GRID_COLS; c++) {
                    if(grid[r][c] === 0) {
                        placeRandomShape(grid, r, c);
                    }
                }
            }
            
            // ç§»è‡³ç­‰å¾…å€ (ç·Šå¯†æ’åˆ—)
            let spawnY = OFFSET_Y;
            let spawnX = SPAWN_AREA_X;
            
            items.forEach((item, index) => {
                // ç°¡å–®çš„å †ç–Šé‚è¼¯ï¼Œé¿å…å®Œå…¨é‡ç–Š
                item.x = spawnX + (Math.random() * 20);
                item.y = spawnY;
                
                // å¾€ä¸‹å †ç–Š
                spawnY += 60; 
                if (spawnY > canvas.height - 100) {
                    spawnY = OFFSET_Y; // å›åˆ°é ‚éƒ¨
                    spawnX += 50; // å¾€å³ç§»ä¸€é» (é›–ç„¶ç©ºé–“æœ‰é™)
                }

                // éš¨æ©Ÿæ—‹è½‰
                let rots = Math.floor(Math.random() * 4);
                for(let i=0; i<rots; i++) item.rotate();
            });
        }

        function placeRandomShape(grid, r, c) {
            let shapesToTry = [...SHAPES].sort(() => Math.random() - 0.5);
            for (let shape of shapesToTry) {
                if (canFit(grid, r, c, shape)) {
                    let templateKey = assignTheme(shape);
                    items.push(new Item(shape, 0, 0, templateKey));
                    markGrid(grid, r, c, shape, 1);
                    return;
                }
            }
        }

        function canFit(grid, r, c, shape) {
            let rows = shape.length;
            let cols = shape[0].length;
            if (r + rows > GRID_ROWS || c + cols > GRID_COLS) return false;
            for(let i=0; i<rows; i++) {
                for(let j=0; j<cols; j++) {
                    if (shape[i][j] === 1 && grid[r+i][c+j] === 1) return false;
                }
            }
            return true;
        }

        function markGrid(grid, r, c, shape, val) {
            let rows = shape.length;
            let cols = shape[0].length;
            for(let i=0; i<rows; i++) {
                for(let j=0; j<cols; j++) {
                    if (shape[i][j] === 1) grid[r+i][c+j] = val;
                }
            }
        }

        function assignTheme(shape) {
            let area = 0;
            shape.flat().forEach(v => area += v);
            if (area === 1) return 'eraser';
            if (shape.length === 1 || shape[0].length === 1) {
                if (area >= 3) return 'ruler';
                return 'pencil_box';
            }
            let isRect = true;
            for(let row of shape) if(row.includes(0)) isRect = false;
            
            if (isRect) {
                if (area >= 4) return Math.random() > 0.5 ? 'book' : 'notebook';
                return 'tetris';
            }
            let rand = Math.random();
            if (rand < 0.3) return 'headphones';
            if (rand < 0.6) return 'gameboy';
            return 'tetris';
        }

        // --- äº’å‹•è™•ç† ---

        function checkCollision(currentItem, targetGridX, targetGridY) {
            // é‚Šç•Œ
             for(let r=0; r<currentItem.rows; r++) {
                for(let c=0; c<currentItem.cols; c++) {
                    if (currentItem.shape[r][c] === 1) {
                        let gx = targetGridX + c;
                        let gy = targetGridY + r;
                        if (gx < 0 || gx >= GRID_COLS || gy < 0 || gy >= GRID_ROWS) return true;
                    }
                }
            }
            // é‡ç–Š
            for (let other of items) {
                if (other === currentItem || !other.isInside) continue;
                let otherGridX = Math.round((other.x - OFFSET_X) / GRID_SIZE);
                let otherGridY = Math.round((other.y - OFFSET_Y) / GRID_SIZE);
                
                for(let r=0; r<currentItem.rows; r++) {
                    for(let c=0; c<currentItem.cols; c++) {
                        if(currentItem.shape[r][c] === 1) {
                            let absX = targetGridX + c;
                            let absY = targetGridY + r;
                            let relX = absX - otherGridX;
                            let relY = absY - otherGridY;
                            if (relX >= 0 && relX < other.cols && relY >= 0 && relY < other.rows) {
                                if (other.shape[relY][relX] === 1) return true;
                            }
                        }
                    }
                }
            }
            return false;
        }

        function updateStats() {
            let usedArea = 0;
            items.forEach(item => { if (item.isInside) usedArea += item.area; });
            let percentage = Math.round((usedArea / (GRID_COLS * GRID_ROWS)) * 100);
            uiCoverage.innerText = percentage + "%";
            
            if (percentage === 100) {
                uiFeedback.innerHTML = "ğŸ† <span style='color:green'>æ­å–œï¼ä»»å‹™å®Œæˆï¼</span>";
                if(navigator.vibrate) navigator.vibrate([100,50,100]);
            }
        }

        function draw() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // ç¹ªè£½èƒŒåŒ…åº•åœ– (åƒ…ç¹ªè£½èƒŒåŒ…å€åŸŸ)
            ctx.fillStyle = "white";
            ctx.fillRect(OFFSET_X, OFFSET_Y, BACKPACK_W, BACKPACK_H);
            
            // ç¶²æ ¼
            ctx.beginPath();
            ctx.strokeStyle = "#eee";
            ctx.lineWidth = 1;
            for (let i = 0; i <= GRID_COLS; i++) {
                ctx.moveTo(OFFSET_X + i * GRID_SIZE, OFFSET_Y);
                ctx.lineTo(OFFSET_X + i * GRID_SIZE, OFFSET_Y + BACKPACK_H);
            }
            for (let j = 0; j <= GRID_ROWS; j++) {
                ctx.moveTo(OFFSET_X, OFFSET_Y + j * GRID_SIZE);
                ctx.lineTo(OFFSET_X + BACKPACK_W, OFFSET_Y + j * GRID_SIZE);
            }
            ctx.stroke();
            
            // èƒŒåŒ…é‚Šæ¡†
            ctx.strokeStyle = "#795548";
            ctx.lineWidth = 3;
            ctx.strokeRect(OFFSET_X, OFFSET_Y, BACKPACK_W, BACKPACK_H);
            
            // ç‰©å“å€æ¨™ç¤º
            ctx.fillStyle = "#8d6e63";
            ctx.font = "14px Arial";
            ctx.fillText("ğŸ“¦ ç‰©å“å€", SPAWN_AREA_X, OFFSET_Y - 5);

            items.forEach(item => {
                if (item !== draggedItem) item.draw(ctx);
            });
            
            if (draggedItem) {
                ctx.save();
                ctx.globalAlpha = 0.8;
                ctx.shadowColor = "black";
                ctx.shadowBlur = 15;
                draggedItem.draw(ctx);
                ctx.restore();
            }
        }

        // --- Pointer Events (Touch + Mouse) ---
        function getPos(e) {
            const rect = canvas.getBoundingClientRect();
            const cx = e.touches ? e.touches[0].clientX : e.clientX;
            const cy = e.touches ? e.touches[0].clientY : e.clientY;
            return { x: cx - rect.left, y: cy - rect.top };
        }

        function handleStart(e) {
            if (e.type === 'touchstart') e.preventDefault();
            const pos = getPos(e);
            const now = new Date().getTime();

            for (let i = items.length - 1; i >= 0; i--) {
                let item = items[i];
                if (item.hitTest(pos.x, pos.y)) {
                    if (now - lastClickTime < 300) {
                        item.rotate();
                        uiFeedback.innerText = "ğŸ”„ å·²æ—‹è½‰";
                        draw();
                        lastClickTime = 0;
                        return;
                    }
                    lastClickTime = now;
                    draggedItem = item;
                    dragOffsetX = pos.x - item.x;
                    dragOffsetY = pos.y - item.y;
                    items.splice(i, 1);
                    items.push(item);
                    uiFeedback.innerText = `ç§»å‹•: ${item.template.name} (é¢ç© ${item.area})`;
                    draw();
                    return;
                }
            }
        }

        function handleMove(e) {
            if (draggedItem) {
                if (e.type === 'touchmove') e.preventDefault();
                const pos = getPos(e);
                draggedItem.x = pos.x - dragOffsetX;
                draggedItem.y = pos.y - dragOffsetY;
                draw();
            }
        }

        function handleEnd(e) {
            if (draggedItem) {
                const gx = Math.round((draggedItem.x - OFFSET_X) / GRID_SIZE);
                const gy = Math.round((draggedItem.y - OFFSET_Y) / GRID_SIZE);
                if (!checkCollision(draggedItem, gx, gy)) {
                    draggedItem.x = OFFSET_X + gx * GRID_SIZE;
                    draggedItem.y = OFFSET_Y + gy * GRID_SIZE;
                    draggedItem.isInside = true;
                    uiFeedback.innerText = "âœ… æ”¾ç½®æˆåŠŸ";
                    if(navigator.vibrate) navigator.vibrate(30);
                } else {
                    draggedItem.isInside = false;
                    uiFeedback.innerText = "â›” æ”¾ä¸ä¸‹ï¼Œè«‹é‡è©¦æˆ–æ—‹è½‰";
                }
                updateStats();
                draggedItem = null;
                draw();
            }
        }

        canvas.addEventListener('mousedown', handleStart);
        canvas.addEventListener('mousemove', handleMove);
        canvas.addEventListener('mouseup', handleEnd);
        canvas.addEventListener('touchstart', handleStart, {passive: false});
        canvas.addEventListener('touchmove', handleMove, {passive: false});
        canvas.addEventListener('touchend', handleEnd);

        document.getElementById('btn-new').addEventListener('click', () => {
            createSolvablePuzzle();
            updateStats();
            draw();
            uiFeedback.innerText = "æ–°é—œå¡å·²ç”Ÿæˆï¼";
        });
        
        document.getElementById('btn-hint').addEventListener('click', () => {
            uiFeedback.innerHTML = "ğŸ’¡ æç¤ºï¼šå¿«é€Ÿé»æ“Šç‰©å“<b>å…©ä¸‹</b>å¯ä»¥æ—‹è½‰ï¼";
        });

        // Init
        createSolvablePuzzle();
        draw();

    </script>
</body>
</html>
