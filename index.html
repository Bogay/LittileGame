<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>èƒŒåŒ…æ•¸å­¸å¤§å¸« - æ‹¼åœ–æŒ‘æˆ°ç‰ˆ</title>
    <style>
        body {
            font-family: 'Segoe UI', 'Microsoft JhengHei', sans-serif;
            background-color: #fff4e6; /* æº«æš–èƒŒæ™¯ */
            display: flex;
            flex-direction: column;
            align-items: center;
            margin: 0;
            padding: 10px;
            overscroll-behavior: none;
            user-select: none; /* é˜²æ­¢é¸å–æ–‡å­— */
        }
        h1 { color: #5d4037; margin-bottom: 5px; font-size: 24px; }
        
        .game-wrapper {
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            gap: 20px;
            background: white;
            padding: 20px;
            border-radius: 20px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.15);
            max-width: 100%;
            border: 4px solid #ffcc80;
        }

        canvas {
            border: 3px solid #8d6e63;
            border-radius: 10px;
            cursor: grab;
            background-color: #eceff1; /* æ ¼å­èƒŒæ™¯è‰² */
            touch-action: none;
        }
        canvas:active { cursor: grabbing; }
        
        .sidebar {
            width: 260px;
            display: flex;
            flex-direction: column;
            gap: 15px;
        }
        .info-panel {
            background: #e1f5fe;
            padding: 15px;
            border-radius: 15px;
            border-left: 6px solid #03a9f4;
            box-shadow: 0 2px 5px rgba(0,0,0,0.05);
        }
        .info-panel h3 { margin: 0 0 8px 0; font-size: 18px; color: #0277bd; }
        .stat { font-size: 16px; margin-bottom: 5px; color: #455a64; }
        .highlight { color: #d32f2f; font-weight: bold; font-size: 1.2em; }
        
        .controls {
            margin-top: auto;
            display: flex;
            flex-direction: column;
            gap: 10px;
        }
        button {
            padding: 12px;
            font-size: 18px;
            border: none;
            border-radius: 10px;
            cursor: pointer;
            transition: transform 0.1s, background-color 0.2s;
            font-weight: bold;
            color: white;
            box-shadow: 0 4px 0 rgba(0,0,0,0.1);
        }
        button:active { transform: translateY(2px); box-shadow: none; }
        #btn-spawn { background-color: #66bb6a; } /* ç¶ è‰² */
        #btn-spawn:hover { background-color: #43a047; }
        #btn-clear { background-color: #ef5350; } /* ç´…è‰² */
        #btn-clear:hover { background-color: #e53935; }

        .math-feedback {
            font-size: 18px;
            text-align: center;
            min-height: 30px;
            color: #5d4037;
            font-weight: bold;
            margin: 10px 0;
            padding: 8px;
            background: #fff;
            border-radius: 10px;
            border: 2px dashed #ffb74d;
            width: 90%;
            max-width: 800px;
        }
    </style>
</head>
<body>

    <h1>ğŸ’ æ–‡å…·æ•´ç†å°é”äºº</h1>
    <div class="math-feedback" id="math-feedback">è«‹å°‡æ–‡å…·æ‹–é€²èƒŒåŒ…æ ¼å­è£¡ï¼</div>

    <div class="game-wrapper">
        <canvas id="gameCanvas" width="850" height="500"></canvas>

        <div class="sidebar">
            <div class="info-panel">
                <h3>ğŸ“Š èƒŒåŒ…ç©ºé–“</h3>
                <div class="stat">ç¸½æ ¼æ•¸ï¼š80 æ ¼</div>
                <div class="stat">å·²ç”¨é¢ç©ï¼š<span id="used-area" class="highlight">0</span> æ ¼</div>
                <div class="stat">ç©ºé–“åˆ©ç”¨ç‡ï¼š<span id="coverage">0%</span></div>
            </div>

            <div class="info-panel" style="background: #fff8e1; border-left-color: #ffc107;">
                <h3>ğŸ’¡ ç‰©å“æ•¸å­¸</h3>
                <div id="current-item-info" style="line-height: 1.6;">
                    é»æ“Šç‰©å“çœ‹è©³ç´°è³‡è¨Š
                </div>
            </div>

            <div class="controls">
                <button id="btn-spawn">ğŸ çµ¦æˆ‘æ–°æ–‡å…·</button>
                <button id="btn-clear">ğŸ—‘ï¸ å…¨éƒ¨æ¸…ç©º</button>
            </div>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const uiUsedArea = document.getElementById('used-area');
        const uiCoverage = document.getElementById('coverage');
        const uiItemInfo = document.getElementById('current-item-info');
        const uiFeedback = document.getElementById('math-feedback');

        // éŠæˆ²åƒæ•¸
        const GRID_SIZE = 40; 
        const GRID_COLS = 10; 
        const GRID_ROWS = 8;  
        
        const OFFSET_X = 40;
        const OFFSET_Y = 60;
        
        const BACKPACK_W = GRID_COLS * GRID_SIZE;
        const BACKPACK_H = GRID_ROWS * GRID_SIZE;

        let items = [];
        let draggedItem = null;
        let dragOffsetX = 0;
        let dragOffsetY = 0;

        // --- å®šç¾©ä¸è¦å‰‡å½¢ç‹€ (1ä»£è¡¨æœ‰æ–¹å¡Šï¼Œ0ä»£è¡¨ç©º) ---
        // ä½¿ç”¨ shape çŸ©é™£å®šç¾©
        const ITEM_TYPES = [
            // è¦å‰‡çŸ©å½¢ (å¼·èª¿é•·xå¯¬)
            { name: "æ•¸å­¸èª²æœ¬", shape: [[1,1],[1,1],[1,1]], color: "#42a5f5", icon: "ğŸ“˜", type: "rect" },
            { name: "é‰›ç­†ç›’", shape: [[1,1,1]], color: "#ef5350", icon: "âœï¸", type: "rect" },
            { name: "ä¾¿ç•¶ç›’", shape: [[1,1],[1,1]], color: "#ffa726", icon: "ğŸ±", type: "rect" },
            { name: "å¤§åœ–ç•«ç´™", shape: [[1,1,1],[1,1,1],[1,1,1]], color: "#ab47bc", icon: "ğŸ¨", type: "rect" },
            { name: "é•·å°º", shape: [[1],[1],[1],[1]], color: "#8d6e63", icon: "ğŸ“", type: "rect" },
            
            // ä¸è¦å‰‡å½¢ç‹€ (å¼·èª¿é¢ç©åŠ ç¸½)
            { name: "Lå‹å°º", shape: [[1,0],[1,0],[1,1]], color: "#26a69a", icon: "ğŸ“", type: "poly" },
            { name: "è¿´æ—‹é¢", shape: [[1,1],[0,1]], color: "#7e57c2", icon: "ğŸªƒ", type: "poly" },
            { name: "çç›ƒ", shape: [[1,1,1],[0,1,0]], color: "#fdd835", icon: "ğŸ†", type: "poly" },
            { name: "è€³æ©Ÿ", shape: [[1,1,1],[1,0,1]], color: "#ec407a", icon: "ğŸ§", type: "poly" },
            { name: "ä¿„ç¾…æ–¯æ–¹å¡ŠS", shape: [[0,1,1],[1,1,0]], color: "#9ccc65", icon: "ğŸ§©", type: "poly" },
            { name: "ä¿„ç¾…æ–¯æ–¹å¡ŠT", shape: [[1,1,1],[0,1,0]], color: "#5c6bc0", icon: "ğŸ§©", type: "poly" }
        ];

        class Item {
            constructor(template, x, y) {
                this.name = template.name;
                this.shape = template.shape; // 2D é™£åˆ—
                this.color = template.color;
                this.icon = template.icon;
                this.type = template.type;
                this.x = x;
                this.y = y;
                this.isInside = false;
                
                // è¨ˆç®—å°ºå¯¸
                this.rows = this.shape.length;
                this.cols = this.shape[0].length;
                
                // è¨ˆç®—é¢ç© (æ•¸æ ¼å­)
                this.area = 0;
                for(let r=0; r<this.rows; r++) {
                    for(let c=0; c<this.cols; c++) {
                        if(this.shape[r][c] === 1) this.area++;
                    }
                }
            }

            draw(ctx) {
                ctx.fillStyle = this.color;
                ctx.strokeStyle = "rgba(255,255,255,0.6)";
                ctx.lineWidth = 1;

                // ç¹ªè£½æ–¹å¡Š
                for(let r=0; r<this.rows; r++) {
                    for(let c=0; c<this.cols; c++) {
                        if(this.shape[r][c] === 1) {
                            const drawX = this.x + c * GRID_SIZE;
                            const drawY = this.y + r * GRID_SIZE;
                            
                            // å¡«è‰²
                            ctx.fillRect(drawX, drawY, GRID_SIZE, GRID_SIZE);
                            // æ ¼ç·š
                            ctx.strokeRect(drawX, drawY, GRID_SIZE, GRID_SIZE);
                            
                            // é‚Šæ¡† (æ¯”è¼ƒæ·±)
                            ctx.save();
                            ctx.strokeStyle = "rgba(0,0,0,0.2)";
                            ctx.strokeRect(drawX, drawY, GRID_SIZE, GRID_SIZE);
                            ctx.restore();
                        }
                    }
                }

                // ç¹ªè£½ Icon (ç•«åœ¨å½¢ç‹€çš„ä¸­å¿ƒ)
                ctx.fillStyle = "rgba(255,255,255,0.9)";
                ctx.font = "24px Arial";
                ctx.textAlign = "center";
                ctx.textBaseline = "middle";
                
                // æ‰¾ç¬¬ä¸€å€‹æœ‰æ ¼å­çš„ä½ç½®ç•¶ä½œæ¨™ç¤ºé»ï¼Œæˆ–è€…æ‰¾ä¸­å¿ƒ
                let centerX = this.x + (this.cols * GRID_SIZE) / 2;
                let centerY = this.y + (this.rows * GRID_SIZE) / 2;
                ctx.shadowColor = "black";
                ctx.shadowBlur = 2;
                ctx.fillText(this.icon, centerX, centerY);
                ctx.shadowBlur = 0;
            }
            
            // æª¢æŸ¥æ˜¯å¦é»æ“Šåˆ°å¯¦é«”æ–¹å¡Š (æ’é™¤é€æ˜å€åŸŸ)
            hitTest(mx, my) {
                // å…ˆæª¢æŸ¥ Bounding Box
                if (mx < this.x || mx > this.x + this.cols * GRID_SIZE ||
                    my < this.y || my > this.y + this.rows * GRID_SIZE) {
                    return false;
                }
                
                // æª¢æŸ¥ç´°éƒ¨æ ¼å­
                const col = Math.floor((mx - this.x) / GRID_SIZE);
                const row = Math.floor((my - this.y) / GRID_SIZE);
                
                // é˜²æ­¢é™£åˆ—è¶Šç•Œ
                if (row >= 0 && row < this.rows && col >= 0 && col < this.cols) {
                    return this.shape[row][col] === 1;
                }
                return false;
            }
        }

        function init() {
            spawnItem();
            spawnItem();
            spawnItem();
            draw();
        }

        function spawnItem() {
            const template = ITEM_TYPES[Math.floor(Math.random() * ITEM_TYPES.length)];
            // ç”Ÿæˆåœ¨å³å´å€åŸŸ
            const startX = BACKPACK_W + OFFSET_X + 30 + Math.random() * 50;
            const startY = 50 + Math.random() * 250;
            items.push(new Item(template, startX, startY));
            draw();
        }

        // é€²éšç¢°æ’æª¢æ¸¬ (æ”¯æ´ä¸è¦å‰‡å½¢ç‹€)
        function checkCollision(currentItem, targetGridX, targetGridY) {
            
            // 1. æª¢æŸ¥é‚Šç•Œèˆ‡èƒŒåŒ…ç¯„åœ
            for(let r=0; r<currentItem.rows; r++) {
                for(let c=0; c<currentItem.cols; c++) {
                    if (currentItem.shape[r][c] === 1) {
                        let globalX = targetGridX + c;
                        let globalY = targetGridY + r;
                        
                        // å‡ºç•Œæª¢æŸ¥
                        if (globalX < 0 || globalX >= GRID_COLS || globalY < 0 || globalY >= GRID_ROWS) {
                            return true;
                        }
                    }
                }
            }

            // 2. æª¢æŸ¥èˆ‡å…¶ä»–ç‰©å“é‡ç–Š
            for (let other of items) {
                if (other === currentItem || !other.isInside) continue;
                
                let otherGridX = Math.round((other.x - OFFSET_X) / GRID_SIZE);
                let otherGridY = Math.round((other.y - OFFSET_Y) / GRID_SIZE);
                
                // å…©å€‹ç‰©å“çš„è¿´åœˆæ¯”å°
                for(let r=0; r<currentItem.rows; r++) {
                    for(let c=0; c<currentItem.cols; c++) {
                        if(currentItem.shape[r][c] === 1) {
                            // è¨ˆç®—é€™å€‹æ ¼å­åœ¨å…¨åŸŸåº§æ¨™çš„ä½ç½®
                            let absX = targetGridX + c;
                            let absY = targetGridY + r;
                            
                            // æª¢æŸ¥å°æ–¹ç‰©å“åœ¨é€™å€‹å…¨åŸŸåº§æ¨™æ˜¯å¦æœ‰æ–¹å¡Š
                            // å°æ–¹çš„ç›¸å°åº§æ¨™
                            let relOtherX = absX - otherGridX;
                            let relOtherY = absY - otherGridY;
                            
                            if (relOtherX >= 0 && relOtherX < other.cols &&
                                relOtherY >= 0 && relOtherY < other.rows) {
                                if (other.shape[relOtherY][relOtherX] === 1) {
                                    return true; // æ’åˆ°äº†
                                }
                            }
                        }
                    }
                }
            }
            return false;
        }

        function updateStats() {
            let usedArea = 0;
            items.forEach(item => {
                if (item.isInside) usedArea += item.area;
            });
            let totalArea = GRID_COLS * GRID_ROWS;
            uiUsedArea.innerText = usedArea;
            uiCoverage.innerText = Math.round((usedArea / totalArea) * 100) + "%";
        }

        function draw() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // èƒŒåŒ…å€åŸŸ
            // ç¹ªè£½æ ¼å­åº•åœ–
            ctx.fillStyle = "#fafafa";
            ctx.fillRect(OFFSET_X, OFFSET_Y, BACKPACK_W, BACKPACK_H);
            
            ctx.strokeStyle = "#e0e0e0"; // æ·ºç°è‰²æ ¼ç·š
            ctx.lineWidth = 1;
            
            // ç•«ç¶²æ ¼
            ctx.beginPath();
            for (let i = 0; i <= GRID_COLS; i++) {
                ctx.moveTo(OFFSET_X + i * GRID_SIZE, OFFSET_Y);
                ctx.lineTo(OFFSET_X + i * GRID_SIZE, OFFSET_Y + BACKPACK_H);
            }
            for (let j = 0; j <= GRID_ROWS; j++) {
                ctx.moveTo(OFFSET_X, OFFSET_Y + j * GRID_SIZE);
                ctx.lineTo(OFFSET_X + BACKPACK_W, OFFSET_Y + j * GRID_SIZE);
            }
            ctx.stroke();
            
            // èƒŒåŒ…é‚Šæ¡†
            ctx.strokeStyle = "#8d6e63";
            ctx.lineWidth = 4;
            ctx.strokeRect(OFFSET_X, OFFSET_Y, BACKPACK_W, BACKPACK_H);
            
            // æ–‡å­—æ¨™ç±¤
            ctx.fillStyle = "#5d4037";
            ctx.font = "bold 16px Arial";
            ctx.fillText(`èƒŒåŒ…å€åŸŸ (${GRID_COLS}x${GRID_ROWS})`, OFFSET_X, OFFSET_Y - 10);
            ctx.fillText("æ–°ç‰©å“å€ ->", BACKPACK_W + OFFSET_X + 30, OFFSET_Y - 10);

            // ç¹ªè£½ç‰©å“
            items.forEach(item => {
                if (item !== draggedItem) item.draw(ctx);
            });
            
            // æ‹–æ›³ä¸­çš„ç‰©å“ (åŠ ä¸ŠåŠé€æ˜é™°å½±)
            if (draggedItem) {
                ctx.save();
                ctx.globalAlpha = 0.5;
                ctx.translate(5, 5); // é™°å½±åç§»
                draggedItem.draw(ctx);
                ctx.restore();
                
                draggedItem.draw(ctx);
            }
        }

        // --- è¼¸å…¥è™•ç† (æ»‘é¼  + è§¸æ§) ---

        function getPointerPos(e) {
            const rect = canvas.getBoundingClientRect();
            const clientX = e.touches ? e.touches[0].clientX : e.clientX;
            const clientY = e.touches ? e.touches[0].clientY : e.clientY;
            return {
                x: clientX - rect.left,
                y: clientY - rect.top
            };
        }

        function handleStart(e) {
            if (e.type === 'touchstart') e.preventDefault();
            const pos = getPointerPos(e);

            // å€’åºæª¢æŸ¥ï¼Œå…ˆé¸æœ€ä¸Šå±¤
            for (let i = items.length - 1; i >= 0; i--) {
                let item = items[i];
                if (item.hitTest(pos.x, pos.y)) {
                    
                    draggedItem = item;
                    dragOffsetX = pos.x - item.x;
                    dragOffsetY = pos.y - item.y;
                    
                    // ç§»åˆ°é™£åˆ—æœ€å¾Œ (æœ€ä¸Šå±¤)
                    items.splice(i, 1);
                    items.push(item);

                    // é¡¯ç¤ºè³‡è¨Š
                    let mathText = "";
                    if (item.type === 'rect') {
                        mathText = `<span style="color:#d81b60">é•· ${item.cols} Ã— å¯¬ ${item.rows} = é¢ç© ${item.area}</span>`;
                    } else {
                        mathText = `<span style="color:#00838f">è¤‡åˆå½¢ç‹€é¢ç©ï¼šå…± ${item.area} æ ¼</span>`;
                    }

                    uiItemInfo.innerHTML = `
                        <strong>${item.icon} ${item.name}</strong><br>
                        ${mathText}
                    `;
                    uiFeedback.innerText = `æ­£åœ¨ç§»å‹•ï¼š${item.name}`;
                    uiFeedback.style.color = "#555";
                    
                    draw();
                    return;
                }
            }
        }

        function handleMove(e) {
            if (draggedItem) {
                if (e.type === 'touchmove') e.preventDefault();
                const pos = getPointerPos(e);
                draggedItem.x = pos.x - dragOffsetX;
                draggedItem.y = pos.y - dragOffsetY;
                draw();
            }
        }

        function handleEnd(e) {
            if (draggedItem) {
                // è¨ˆç®—æœ€è¿‘çš„æ ¼ç·š
                const gridX = Math.round((draggedItem.x - OFFSET_X) / GRID_SIZE);
                const gridY = Math.round((draggedItem.y - OFFSET_Y) / GRID_SIZE);

                // é€²è¡Œç²¾ç¢ºç¢°æ’æª¢æ¸¬
                if (!checkCollision(draggedItem, gridX, gridY)) {
                    // å¸é™„
                    draggedItem.x = OFFSET_X + gridX * GRID_SIZE;
                    draggedItem.y = OFFSET_Y + gridY * GRID_SIZE;
                    draggedItem.isInside = true;
                    uiFeedback.innerHTML = `âœ… æˆåŠŸæ”¾å…¥ï¼é¢ç©å¢åŠ  <b>${draggedItem.area}</b>`;
                    uiFeedback.style.color = "green";
                    
                    // æ’­æ”¾éŸ³æ•ˆæ„Ÿçš„éœ‡å‹• (å¦‚æœè£ç½®æ”¯æ´)
                    if (navigator.vibrate) navigator.vibrate(30);
                } else {
                    draggedItem.isInside = false;
                    uiFeedback.innerText = "â›” å“å‘€ï¼Œæ”¾ä¸é€²å»ï¼ç©ºé–“ä¸è¶³æˆ–é‡ç–Šäº†";
                    uiFeedback.style.color = "#d32f2f";
                }

                updateStats();
                draggedItem = null;
                draw();
            }
        }

        // äº‹ä»¶ç›£è½
        canvas.addEventListener('mousedown', handleStart);
        canvas.addEventListener('mousemove', handleMove);
        canvas.addEventListener('mouseup', handleEnd);
        
        canvas.addEventListener('touchstart', handleStart, {passive: false});
        canvas.addEventListener('touchmove', handleMove, {passive: false});
        canvas.addEventListener('touchend', handleEnd);

        document.getElementById('btn-spawn').addEventListener('click', () => {
            spawnItem();
            uiFeedback.innerText = "âœ¨ æ–°æ–‡å…·é€é”ï¼";
        });

        document.getElementById('btn-clear').addEventListener('click', () => {
            items = [];
            updateStats();
            draw();
            uiFeedback.innerText = "ğŸ—‘ï¸ èƒŒåŒ…å·²æ¸…ç©º";
            uiItemInfo.innerHTML = "é»æ“Šç‰©å“çœ‹è©³ç´°è³‡è¨Š";
        });

        init();
    </script>
</body>
</html>
